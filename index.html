<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tracklist with Interactive Waveform Audio Player</title>
  <style>
    /* ==========================================================================
       CSS Reset (Eric Meyer v2.0 adapted)
       ----------------------------------------------------------------------------
       Neutralizes default browser styles for consistency across browsers.
       Source: [https://meyerweb.com/eric/tools/css/reset/](https://meyerweb.com/eric/tools/css/reset/)
    ========================================================================== */
    html, body, div, span, applet, object, iframe,
    h1, h2, h3, h4, h5, h6, p, blockquote, pre,
    a, abbr, acronym, address, big, cite, code,
    del, dfn, em, img, ins, kbd, q, s, samp,
    small, strike, strong, sub, sup, tt, var,
    b, u, i, center,
    dl, dt, dd, ol, ul, li,
    fieldset, form, label, legend,
    table, caption, tbody, tfoot, thead, tr, th, td,
    article, aside, canvas, details, embed,
    figure, figcaption, footer, header, hgroup,
    menu, nav, output, ruby, section, summary,
    time, mark, audio, video {
      margin: 0;
      padding: 0;
      border: 0;
      font-size: 100%;
      font: inherit;
      vertical-align: baseline;
      outline: 0;
    }
    /* HTML5 display role reset for older browsers */
    article, aside, details, figcaption, figure,
    footer, header, hgroup, menu, nav, section {
      display: block;
    }
    body {
      line-height: 1;
      font-family: Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      background: var(--background);
      color: var(--text-color-bright);
    }
    ol, ul {
      list-style: none;
    }
    blockquote, q {
      quotes: none;
    }
    blockquote::before, blockquote::after,
    q::before, q::after {
      content: '';
      content: none;
    }
    table {
      border-collapse: collapse;
      border-spacing: 0;
    }
    /* ==========================================================================
       Theme Variables & Auto Dark Mode by System Preference
       ----------------------------------------------------------------------------
       Define base variables; auto switch for light/dark mode via @media (prefers-color-scheme).
       Benefits: cleaner code, easy theming, no JS needed for theme detection.
    ========================================================================== */
    :root {
      /* Buttons */
      --btn-bg: #383351;
      --btn-color: #fff;
      --btn-hover-bg: #4f4a85;
      /* Text colors */
      --text-color-muted: #555;
      --text-color-bright: #222;
      /* Background */
      --footer-bg: #eee;
      --background: #fff;
      /* Waveform colors */
      --waveform-active: var(--btn-bg);
      --waveform-inactive: var(--text-color-muted);
      --waveform-hover: #fff100;
      /* Spacing & sizing */
      --content-width: 460px;
      --btn-size: 38px;
      --font-family-base: Arial, sans-serif;
      /* Transitions */
      --transition-default: 0.3s ease;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --btn-bg: #a3a3e3;
        --btn-color: #222;
        --btn-hover-bg: #8a8aea;
        --text-color-muted: #ccc;
        --text-color-bright: #f0f0f0;
        --footer-bg: #222;
        --background: #121212;
        --waveform-active: var(--btn-bg);
        --waveform-inactive: var(--text-color-muted);
        --waveform-hover: #5050d4;
      }
    }
    /* ==========================================================================
       Layout & Core Components
    ========================================================================== */
    .content {
      width: var(--content-width);
      margin: 0 auto 32px auto;
      box-sizing: border-box;
      user-select: none;
      display: flex;
      flex-direction: column;
      justify-content: center; /* vertical centering */
    }
    #playlist-container {
      width: 100%;
      box-sizing: border-box;
      user-select: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 32px;
      padding-bottom: 80px; /* reserve space for footer */
    }
    .track-item.content {
      display: flex;
      flex-direction: column;
      width: var(--content-width);
      box-sizing: border-box;
      justify-content: center;
    }
    .track-cover-container {
      width: 100%;
      margin-bottom: 8px;
    }
    .track-cover-container img {
      width: 100%;
      height: auto;
      border-radius: 8px;
      display: block;
      user-select: none;
      pointer-events: none;
    }
    .track-info-container {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      box-sizing: border-box;
      margin-bottom: 8px;
      position: relative;
    }
    .play-btn-container {
      flex: 0 0 auto;
      margin: 0;
      padding: 0;
    }
    .btn-play-pause {
      background: var(--btn-bg);
      color: var(--btn-color);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      width: var(--btn-size);
      height: var(--btn-size);
      padding: 0;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1rem;
      transition: background-color var(--transition-default);
    }
    .btn-play-pause:hover,
    .btn-play-pause:focus-visible {
      background: var(--btn-hover-bg);
      outline-offset: 2px;
      outline: 2px solid var(--btn-hover-bg);
    }
    .artist-title-container {
      flex: 1 1 auto;
      margin: 0 8px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      overflow: hidden;
      min-width: 0;
      user-select: none;
    }
    .track-artist {
      font-weight: 400;
      font-size: 16px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 2px;
      color: var(--text-color-muted);
    }
    .track-title {
      font-weight: 700;
      font-size: 18px;
      line-height: 1.1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-color-bright);
    }
    .meta-info-container {
      flex: 0 0 auto;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: flex-end;
      user-select: none;
      max-height: 100%;
      box-sizing: border-box;
    }
    .genre-date-row {
      display: flex;
      gap: 12px;
      font-weight: 300;
      font-size: 0.9rem;
      white-space: nowrap;
      color: var(--text-color-muted);
    }
    .time-row {
      font-family: monospace;
      letter-spacing: 0.04em;
      min-width: 138px;
      justify-content: flex-end;
      color: var(--text-color-muted);
      font-weight: 300;
      font-size: 0.9rem;
      margin-top: auto;
      display: flex;
      gap: 6px;
      white-space: nowrap;
      align-items: center;
    }
    .time-row .separator {
      user-select: none;
    }
    .waveform-container {
      width: 100%;
      margin-bottom: 8px;
      user-select: none;
      border-radius: 8px;
      overflow: hidden;
    }
    canvas.waveform-canvas {
      height: 110px;
      display: block;
      cursor: pointer;
      border-radius: 8px;
      background: transparent;
    }
    .tracklist-container {
      width: 100%;
      margin-top: 0;
      user-select: none;
    }
    .btn-toggle-tracklist {
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--text-color-muted);
      font-weight: 300;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 6px;
      user-select: none;
      width: 100%;
      justify-content: center;
      padding: 0;
      transition: transform var(--transition-default);
    }
    .btn-toggle-tracklist::after {
      content: 'â–¼';
      font-size: 0.6rem;
      transition: transform var(--transition-default);
    }
    .btn-toggle-tracklist[aria-expanded="true"]::after {
      transform: rotate(-180deg);
    }
    .tracklist-content {
      display: none;
      margin-top: 8px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 150px;
      overflow-y: auto;
      color: var(--text-color-muted);
      width: 100%;
    }
    .tracklist-content.visible {
      display: block;
    }
    /* ==========================================================================
       Footer Controls
    ========================================================================== */
    #footer-controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      background-color: var(--footer-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      user-select: none;
      z-index: 1000;
      padding: 0 20px;
    }
    #footer-controls .footer-inner-container {
      width: var(--content-width);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #footer-controls .btn-play-pause, #footer-controls .btn-prev, #footer-controls .btn-next {
      padding: 0;
      margin-right: 10px;
      font-size: 1.1rem;
      min-width: var(--btn-size);
      cursor: pointer;
      background: var(--btn-bg);
      border: none;
      border-radius: 4px;
      color: var(--btn-color);
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      width: var(--btn-size);
      height: var(--btn-size);
      transition: background-color var(--transition-default);
    }
  
    #footer-controls .btn-play-pause:hover, #footer-controls .btn-prev:hover, #footer-controls .btn-next:hover,
    #footer-controls .btn-play-pause:focus-visible, #footer-controls .btn-prev:focus-visible, #footer-controls .btn-next:focus-visible {
      background: var(--btn-hover-bg);
      outline-offset: 2px;
      outline: 2px solid var(--btn-hover-bg);
    }
  
    /* Volume controls styling */
    #footer-controls .volume-controls {
      margin-left: 20px;
      display: flex;
      align-items: center;
    }
  
    #footer-controls .btn-mute {
      background: transparent;
      border: none;
      cursor: pointer;
      width: var(--btn-size);
      height: var(--btn-size);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color var(--transition-default);
    }
  
    #footer-controls .volume-percent {
      font-size: 0.9rem;
      white-space: nowrap;
      min-width: 45px;
      text-align: right;
      color: var(--text-color-muted);
    }
    #footer-controls .btn-play-pause:hover,
    #footer-controls .btn-play-pause:focus-visible {
      background: var(--btn-hover-bg);
      outline-offset: 2px;
      outline: 2px solid var(--btn-hover-bg);
    }
    #footer-controls input[type=range] {
      width: 120px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-color: var(--background);
      height: 20px;
      border-radius: 5px;
      position: relative;
      overflow: hidden;
      --vol-percent: 100%;
      transition: background var(--transition-default);
    }
    #footer-controls input[type=range]::-webkit-slider-runnable-track {
      height: 20px;
      background: linear-gradient(to right,
        var(--btn-bg) 0%, var(--btn-bg) var(--vol-percent),
        var(--background) var(--vol-percent), var(--background) 100%);
      border-radius: 5px;
    }
    #footer-controls input[type=range]::-moz-range-track {
      height: 20px;
      background: linear-gradient(to right,
        var(--btn-bg) 0%, var(--btn-bg) var(--vol-percent),
        var(--background) var(--vol-percent), var(--background) 100%);
      border-radius: 5px;
      border: none;
    }
    /* Hide slider thumb/knob */
    #footer-controls input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 0;
      height: 0;
      border: none;
      background: transparent;
      cursor: pointer;
    }
    #footer-controls input[type=range]::-moz-range-thumb {
      width: 0;
      height: 0;
      border: none;
      background: transparent;
      cursor: pointer;
    }
    /* SVG icon sizing */
    svg.play-icon, svg.pause-icon, svg.prev-icon, svg.next-icon, svg.mute-icon, svg.unmute-icon {
      width: 20px;
      height: 20px;
      display: block;
      fill: currentColor;
    }
  </style>
</head>
<body>
  <div id="playlist-container" aria-label="Tracklist"></div>
  <div id="footer-controls" aria-label="Global audio controls">
    <div class="footer-inner-container">
      <!-- Prev button -->
      <button class="btn-prev" aria-label="Previous track" title="Previous track"></button>
      <!-- Play/Pause button -->
      <button class="btn-play-pause" aria-label="Play/Pause global audio player" title="Play/Pause global audio player"></button>
      <!-- Next button -->
      <button class="btn-next" aria-label="Next track" title="Next track"></button>
      <!-- Volume control with mute icon and percentage display -->
      <div class="volume-controls">
        <button class="btn-mute" aria-label="Mute/Unmute volume" title="Mute/Unmute volume"></button>
        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1" aria-label="Volume control" />
        <span id="volume-percent" class="volume-percent">100%</span>
      </div>
    </div>
  </div>
<script src="music.js"></script>
<script>
  /* ========= Global Constants & SVG Icons ========= */
  const playSVG = `<svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><polygon points="6 4 20 12 6 20" /></svg>`;
  const pauseSVG = `<svg class="pause-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`;
  const prevSVG = `<svg class="prev-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>`;
  const nextSVG = `<svg class="next-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>`;
  const muteSVG = `<svg class="unmute-icon" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="3 9 9 9 13 5 13 19 9 15 3 15"></polygon><path d="M16.5 7.5a5 5 0 0 1 0 9"></path></svg>`;
  const unmuteSVG = `<svg class="mute-icon" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="3 9 9 9 13 5 13 19 9 15 3 15"></polygon><line x1="18" y1="9" x2="22" y2="15"></line><line x1="22" y1="9" x2="18" y2="15"></line></svg>`;
  /* ========= Accessibility & UX ========= */
  /**
   * Formats seconds to mm:ss string
   * Returns '0:00' if input falsy.
   */
  function formatTime(seconds) {
    if (!seconds) return '0:00';
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${s < 10 ? '0' : ''}${s}`;
  }
  /* ========= Waveform Drawing ========= */
  /**
   * Draws waveform bars on a given 2D canvas context.
   * Colors differ by play progress and hover state.
   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context.
   * @param {Array<number>} ampData - normalized amplitude array (0..1).
   * @param {number} progress - fraction played (0..1).
   * @param {number} width - canvas width.
   * @param {number} height - canvas height.
   * @param {number} hoverIndex - waveform bar index hovered (-1 if none).
   * @param {boolean} isHovering - whether mouse is currently hovering.
   */
  function drawWaveform(ctx, ampData, progress, width, height, hoverIndex = -1, isHovering = false) {
    ctx.clearRect(0, 0, width, height);
    const midY = height / 2;
    const total = ampData.length;
    const barWidth = 2;
    const spaceWidth = 1;
    for (let i = 0; i < total; i++) {
      const amp = ampData[i];
      const barHeight = amp * height;
      const x = i * (barWidth + spaceWidth);
      let fillStyle;
      if (isHovering && i === hoverIndex) {
        fillStyle = getComputedStyle(document.documentElement)
          .getPropertyValue('--waveform-hover').trim();
      } else if (i / total <= progress) {
        fillStyle = getComputedStyle(document.documentElement)
          .getPropertyValue('--waveform-active').trim();
      } else {
        fillStyle = getComputedStyle(document.documentElement)
          .getPropertyValue('--waveform-inactive').trim();
      }
      ctx.fillStyle = fillStyle;
      ctx.fillRect(x, midY - barHeight / 2, barWidth, barHeight);
    }
  }

  /**
   * Interpolates input amplitude data array to fit length required
   * @param {Array<number>} inputData - original amplitude array (length N)
   * @param {number} targetLength - desired length for output data
   * @returns {Array<number>} - interpolated amplitude data
   */
  function interpolateAmplitudeData(inputData, targetLength) {
    const output = [];
    const inputLength = inputData.length;
    for (let i = 0; i < targetLength; i++) {
      // Calculate fractional position in input data
      const pos = i * (inputLength - 1) / (targetLength - 1);
      const idx = Math.floor(pos);
      const frac = pos - idx;
      const v1 = inputData[idx] || 0;
      const v2 = inputData[Math.min(idx + 1, inputLength - 1)] || 0;
      // Linear interpolation
      output[i] = v1 + frac * (v2 - v1);
    }
    return output;
  }

  /* ========= UI Construction & Track Element Creation ========= */
  /**
   * Creates and returns a track DOM element with all UI components,
   * sets up event listeners for playback and waveform interaction.
   * @param {Array} data - musicData single track array.
   * @param {number} idx - track index in playlist.
   * @returns {object} track object containing references to components and audio functions.
   */
  function createTrackElement(data, idx) {
    // Main wrapper
    const trackElem = document.createElement('div');
    trackElem.className = 'track-item content';
    // 1. Cover Art Container
    const coverContainer = document.createElement('div');
    coverContainer.className = 'track-cover-container';
    const coverImg = document.createElement('img');
    coverImg.alt = `${data[2]} cover art`;
    coverImg.className = 'track-cover';
    coverImg.src = `data:image/png;base64,${data[7]}`;
    coverContainer.appendChild(coverImg);
    // 2. Info Container (flex row with 3 sections)
    const infoContainer = document.createElement('div');
    infoContainer.className = 'track-info-container';
    // 2.1 Play / Pause Button Container
    const playBtnContainer = document.createElement('div');
    playBtnContainer.className = 'play-btn-container';
    const playPauseBtn = document.createElement('button');
    playPauseBtn.className = 'btn-play-pause';
    playPauseBtn.setAttribute('aria-label', `Play or Pause ${data[2]} by ${data[1]}`);
    playPauseBtn.innerHTML = playSVG;
    playBtnContainer.appendChild(playPauseBtn);
    // 2.2 Artist & Title Container (stacked)
    const artistTitleContainer = document.createElement('div');
    artistTitleContainer.className = 'artist-title-container';
    const artistDiv = document.createElement('div');
    artistDiv.className = 'track-artist';
    artistDiv.textContent = data[1];
    const titleDiv = document.createElement('div');
    titleDiv.className = 'track-title';
    titleDiv.textContent = data[2];
    artistTitleContainer.appendChild(artistDiv);
    artistTitleContainer.appendChild(titleDiv);
    // 2.3 Meta Info Container - Genre & Date + Time Row
    const metaContainer = document.createElement('div');
    metaContainer.className = 'meta-info-container';
    // Genre and Date Row
    const genreDateRow = document.createElement('div');
    genreDateRow.className = 'genre-date-row';
    const genreDiv = document.createElement('div');
    genreDiv.className = 'track-genre';
    genreDiv.textContent = data[4];
    const dateDiv = document.createElement('div');
    dateDiv.className = 'track-date';
    dateDiv.textContent = data[3];
    genreDateRow.appendChild(genreDiv);
    genreDateRow.appendChild(dateDiv);
    // Time Row: current play time | separator | duration
    const timeRow = document.createElement('div');
    timeRow.className = 'time-row';
    const playPosDiv = document.createElement('div');
    playPosDiv.className = 'play-pos';
    playPosDiv.textContent = '0:00';
    const sepDiv = document.createElement('div');
    sepDiv.className = 'separator';
    sepDiv.textContent = '|';
    const durDiv = document.createElement('div');
    durDiv.className = 'duration';
    durDiv.textContent = formatTime(data[5]);
    timeRow.appendChild(playPosDiv);
    timeRow.appendChild(sepDiv);
    timeRow.appendChild(durDiv);
    metaContainer.appendChild(genreDateRow);
    metaContainer.appendChild(timeRow);
    // Append all 3 info subcontainers
    infoContainer.appendChild(playBtnContainer);
    infoContainer.appendChild(artistTitleContainer);
    infoContainer.appendChild(metaContainer);
    // 3. Waveform Container - canvas for visualization
    const waveformContainer = document.createElement('div');
    waveformContainer.className = 'waveform-container';
    const waveformCanvas = document.createElement('canvas');
    waveformCanvas.className = 'waveform-canvas';
    waveformCanvas.height = 110;
    waveformContainer.appendChild(waveformCanvas);
    // 4. Tracklist Toggle Container (optional tracklist)
    const tracklistContainer = document.createElement('div');
    tracklistContainer.className = 'tracklist-container';
    let toggleBtn = null;
    let tracklistContent = null;
    if (data[6].trim() !== '') {
      toggleBtn = document.createElement('button');
      toggleBtn.className = 'btn-toggle-tracklist';
      toggleBtn.setAttribute('aria-expanded', 'false');
      toggleBtn.textContent = 'Tracklist';
      toggleBtn.addEventListener('click', () => {
        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';
        toggleBtn.setAttribute('aria-expanded', expanded ? 'false' : 'true');
        tracklistContent.classList.toggle('visible');
      });
      tracklistContent = document.createElement('pre');
      tracklistContent.className = 'tracklist-content';
      tracklistContent.textContent = data[6];
      tracklistContainer.appendChild(toggleBtn);
      tracklistContainer.appendChild(tracklistContent);
    }
    // Append all main containers into track item
    trackElem.appendChild(coverContainer);
    trackElem.appendChild(infoContainer);
    trackElem.appendChild(waveformContainer);
    if (tracklistContainer.childNodes.length > 0) {
      trackElem.appendChild(tracklistContainer);
    }
    /* ========= Audio Streaming & Playback Control ========= */
    // Create hidden audio element for fallback streaming
    const audioElement = document.createElement('audio');
    audioElement.src = `music/${data[0]}`;
    audioElement.preload = 'metadata';
    audioElement.style.display = 'none';
    audioElement.controls = false;
    trackElem.appendChild(audioElement);
    // Waveform drawing context and metadata
    const ctx = waveformCanvas.getContext('2d');
    const height = waveformCanvas.height;
    const originalAmpData = JSON.parse(data[8]);
    const duration = data[5];

    // Variables to hold current canvas width and interpolated amp data
    let currentCanvasWidth = 0;
    let ampData = [];

    // Function to update canvas width, amp data interpolation, and draw waveform
    function updateCanvasWidthAndDraw() {
      // Get actual width of waveform container in pixels
      let containerWidth = waveformContainer.offsetWidth;

      // Reduce width by up to 2px to make it divisible by 3
      for (let reduction = 0; reduction <= 2; reduction++) {
        const testWidth = containerWidth - reduction;
        if (testWidth % 3 === 0) {
          containerWidth = testWidth;
          break;
        }
      }

      // Update the canvas width (height stays fixed)
      waveformCanvas.width = containerWidth;
      currentCanvasWidth = containerWidth;

      // Calculate number of peaks based on rule: peak width 2px + 1px space = 3px per peak
      const numPeaks = containerWidth / 3;

      // Interpolate amplitude data to numPeaks length
      ampData = interpolateAmplitudeData(originalAmpData, numPeaks);

      // Draw initial waveform with zero progress
      drawWaveform(ctx, ampData, 0, waveformCanvas.width, height);
    }

    updateCanvasWidthAndDraw();

    /* ========= Playback Progress Updates & Waveform Interaction ========= */
    // State vars to handle waveform interaction
    let mouseHovering = false;
    let hoverIndex = -1;
    // Update waveform, time display as audio plays (unless hovering)
    audioElement.addEventListener('timeupdate', () => {
      if (!mouseHovering) {
        const current = audioElement.currentTime;
        const dur = audioElement.duration || duration;
        const prog = dur ? current / dur : 0;
        drawWaveform(ctx, ampData, prog, currentCanvasWidth, height);
        playPosDiv.textContent = formatTime(current);
        durDiv.textContent = formatTime(dur);
      }
    });
    // On track end, reset UI and play next track
    audioElement.addEventListener('ended', () => {
      playPauseBtn.innerHTML = playSVG;
      if (playingIndex === idx) {
        playingIndex = -1;
        updateFooter(null, null, -1);
        playNextTrack(idx);
      }
    });
    // Play/Pause button toggles playback state for this track
    playPauseBtn.addEventListener('click', () => {
      if (audioElement.paused) {
        // Pause all other track audios
        tracks.forEach(({ audio, btnPlay }, i) => {
          if (i !== idx) {
            audio?.pause();
            btnPlay.innerHTML = playSVG;
          }
        });
        audioElement.play();
        playPauseBtn.innerHTML = pauseSVG;
        playingIndex = idx;
        updateFooter(audioElement, playPauseBtn, idx);
      } else {
        audioElement.pause();
        playPauseBtn.innerHTML = playSVG;
        if (playingIndex === idx) playingIndex = -1;
        updateFooter(null, null, -1);
      }
    });
    // Clicking waveform seeks playback position
    waveformCanvas.addEventListener('click', e => {
      const rect = waveformCanvas.getBoundingClientRect();
      const ratio = (e.clientX - rect.left) / rect.width;
      const dur = audioElement.duration || duration;
      audioElement.currentTime = ratio * dur;
      drawWaveform(ctx, ampData, ratio, currentCanvasWidth, height);
    });
    // Hovering waveform shows hover time, highlights bar
    waveformCanvas.addEventListener('mousemove', e => {
      mouseHovering = true;
      const rect = waveformCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const ratio = x / rect.width;
      hoverIndex = Math.min(Math.max(Math.floor(ratio * ampData.length), 0), ampData.length - 1);
      const dur = audioElement.duration || duration;
      playPosDiv.textContent = formatTime(ratio * dur);
      durDiv.textContent = formatTime(dur);
      const prog = audioElement.currentTime / dur;
      drawWaveform(ctx, ampData, prog, currentCanvasWidth, height, hoverIndex, true);
    });
    // Leaving waveform resets to current playback time display & bar
    waveformCanvas.addEventListener('mouseleave', () => {
      mouseHovering = false;
      hoverIndex = -1;
      const dur = audioElement.duration || duration;
      const curTime = audioElement.currentTime;
      const prog = dur ? curTime / dur : 0;
      drawWaveform(ctx, ampData, prog, currentCanvasWidth, height);
      playPosDiv.textContent = formatTime(curTime);
      durDiv.textContent = formatTime(dur);
    });

    // Observe width changes of waveform container and update canvas accordingly
    const resizeObserver = new ResizeObserver(() => {
      updateCanvasWidthAndDraw();
      // After resizing, redraw the waveform progress if audio is playing
      if (!audioElement.paused) {
        const curDur = audioElement.duration || duration;
        const prog = curDur ? audioElement.currentTime / curDur : 0;
        drawWaveform(ctx, ampData, prog, currentCanvasWidth, height);
      }
    });
    resizeObserver.observe(waveformContainer);

    // Return track object with references & control functions
    return {
      container: trackElem,
      audio: audioElement,
      btnPlay: playPauseBtn,
      timeDisplay: timeRow,
      canvasCtx: ctx,
      ampData,
      width: currentCanvasWidth,
      height,
      currentTimeFn: () => audioElement.currentTime,
      playAudioFn: () => audioElement.play(),
      pauseAudioFn: () => audioElement.pause(),
      updateCanvasWidthAndDraw
    };
  }
  /* ========= Global State Management & Playback Control ========= */
  const tracks = [];
  let playingIndex = -1;
  let isMuted = false;
  let prevVolume = 1;

  // Select DOM elements
  const footerPlayBtn = document.querySelector('#footer-controls .btn-play-pause');
  const footerPrevBtn = document.querySelector('#footer-controls .btn-prev');
  const footerNextBtn = document.querySelector('#footer-controls .btn-next');
  const footerMuteBtn = document.querySelector('#footer-controls .btn-mute');
  const footerVolumeInput = document.querySelector('#footer-controls input[type="range"]');
  const volumePercentSpan = document.querySelector('#footer-controls #volume-percent');

  /**
   * Updates the mute button icon based on current mute state
   */
  function updateMuteButton() {
    if (isMuted) {
      footerMuteBtn.innerHTML = unmuteSVG;
    } else {
      footerMuteBtn.innerHTML = muteSVG;
    }
  }

  /**
   * Updates the volume percentage display
   * @param {number} volume - Volume value between 0 and 1
   */
  function updateVolumePercent(volume) {
    const percent = Math.round(volume * 100);
    volumePercentSpan.textContent = `${percent}%`;
  }
  /**
   * Updates the global footer controls:
   * - Synchronizes play/pause icon and state
   * - Associates global controls with the active track
   * - Adjusts volume slider fill percentage
   * @param {HTMLAudioElement|null} audio - currently playing audio or null if none.
   * @param {HTMLButtonElement|null} playBtn - corresponding play button or null.
   * @param {number} idx - current track index or -1 if none.
   */
  function updateFooter(audio, playBtn, idx) {
    if (audio || playBtn) {
      const paused = audio ? audio.paused : playBtn.innerHTML === playSVG;
      footerPlayBtn.innerHTML = paused ? playSVG : pauseSVG;
      footerPlayBtn.disabled = false;
      footerPlayBtn._linkedAudio = audio;
      footerPlayBtn._linkedPlayBtn = playBtn;
      footerPlayBtn._linkedIndex = idx;
      if (audio) footerVolumeInput.value = audio.volume;
      updateVolumeBar(audio ? audio.volume : 1);
    } else {
      footerPlayBtn.innerHTML = playSVG;
      footerPlayBtn.disabled = true;
      footerPlayBtn._linkedAudio = null;
      footerPlayBtn._linkedPlayBtn = null;
      footerPlayBtn._linkedIndex = -1;
      updateVolumeBar(1);
    }
  }
  /**
   * Updates the CSS variable controlling volume slider's filled track
   * @param {number} volume - value between 0 and 1
   */
  function updateVolumeBar(volume) {
    const perc = Math.round(volume * 100);
    footerVolumeInput.style.setProperty('--vol-percent', perc + '%');
  }
  /**
   * Plays the next track in the playlist, if any.
   * Pauses all other tracks.
   * Scrolls the new track into vertical center view if not fully visible.
   * @param {number} currentIndex - index of the track that just ended.
   */
  function playNextTrack(currentIndex) {
    let nextIdx = currentIndex + 1;
    if (nextIdx >= tracks.length) {
      updateFooter(null, null, -1);
      return; // No more tracks
    }
    const { audio, btnPlay, container } = tracks[nextIdx];
    tracks.forEach(({ audio: a, btnPlay: b }) => {
      if (a && a !== audio) {
        a.pause();
        b.innerHTML = playSVG;
      }
    });
    audio.currentTime = 0;
    audio.play();
    btnPlay.innerHTML = pauseSVG;
    playingIndex = nextIdx;
    updateFooter(audio, btnPlay, nextIdx);
    // Scroll track element into vertical center of viewport if not fully visible
    const bounding = container.getBoundingClientRect();
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    const isFullyVisible = bounding.top >= 0 && bounding.bottom <= viewportHeight;
    if (!isFullyVisible) {
      const scrollToY = window.scrollY + bounding.top - (viewportHeight / 2) + (bounding.height / 2);
      window.scrollTo({
        top: scrollToY,
        behavior: 'smooth'
      });
    }
  }
  /* ========= Global Footer Controls Event Handlers ========= */
  // Global footer play/pause button toggles currently playing track
  footerPlayBtn.addEventListener('click', () => {
    const audio = footerPlayBtn._linkedAudio;
    const playBtn = footerPlayBtn._linkedPlayBtn;
    if (!audio) return;
    if (audio.paused) {
      // Pause all other tracks except this one
      tracks.forEach(({ audio: a, btnPlay: b }) => {
        if (a && a !== audio) {
          a.pause();
          b.innerHTML = playSVG;
        }
      });
      audio.play();
      playBtn.innerHTML = pauseSVG;
      footerPlayBtn.innerHTML = pauseSVG;
    } else {
      audio.pause();
      playBtn.innerHTML = playSVG;
      footerPlayBtn.innerHTML = playSVG;
    }
  });
  // Volume slider input event updates all track volumes
  footerVolumeInput.addEventListener('input', e => {
    const vol = parseFloat(e.target.value);
    tracks.forEach(({ audio }) => {
      if (audio) audio.volume = vol;
    });
    updateVolumeBar(vol);
    updateVolumePercent(vol);
  
    // Update mute button state when volume reaches 0 or non-zero
    if (vol === 0) {
      isMuted = true;
      prevVolume = 0.05; // Set prevVolume to 0.05 when volume reaches 0
    } else if (isMuted) {
      isMuted = false;
      prevVolume = vol; // Update prevVolume to current volume
    }
    updateMuteButton();
  });
  // Volume slider mouse wheel controls volume in steps
  footerVolumeInput.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY || e.detail || e.wheelDelta;
    const step = 0.05;
    let vol = parseFloat(footerVolumeInput.value);
    vol += delta < 0 ? step : -step;
    vol = Math.min(1, Math.max(0, vol));
    footerVolumeInput.value = vol;
    tracks.forEach(({ audio }) => {
      if (audio) audio.volume = vol;
    });
    updateVolumeBar(vol);
    updateVolumePercent(vol);
  
    // Update mute button state when volume reaches 0 or non-zero
    if (vol === 0) {
      isMuted = true;
      prevVolume = 0.05; // Set prevVolume to 0.05 when volume reaches 0
    } else if (isMuted) {
      isMuted = false;
      prevVolume = vol; // Update prevVolume to current volume
    }
    updateMuteButton();
  }, { passive: false });
  /* ========= Keyboard Shortcut Handlers ========= */
  // Keyboard shortcuts for playback control
  window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      e.preventDefault();
      footerPlayBtn.click();
    } else if (e.code === 'ArrowDown' || e.code === 'ArrowUp') {
      if (playingIndex === -1) return;
      e.preventDefault();

      if (e.code === 'ArrowDown') {
        footerNextBtn.click();
      } else {
        footerPrevBtn.click();
      }
    } else if (e.code === 'KeyM' || e.code === 'Numpad0') { // M key or Numpad 0 for mute
      e.preventDefault();
      footerMuteBtn.click();
    }
  });
  // Keyboard shortcuts for playback skip (left/right arrows)
  window.addEventListener('keydown', e => {
    if (playingIndex === -1) return;
    const currentAudio = tracks[playingIndex]?.audio;
    if (!currentAudio) return;
    const skipSmall = 10; // seconds for normal arrow keys
    const skipLarge = 60; // seconds for shift + arrow keys
    if (e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
      e.preventDefault();
      const direction = e.code === 'ArrowRight' ? 1 : -1;
      const skipAmount = e.shiftKey ? skipLarge : skipSmall;
      let newTime = currentAudio.currentTime + direction * skipAmount;
      if (newTime < 0) newTime = 0;
      if (currentAudio.duration && newTime > currentAudio.duration) newTime = currentAudio.duration;
      currentAudio.currentTime = newTime;
    }
  });
  /* ========= Initialization & Lifecycle ========= */
  const playlistRoot = document.getElementById('playlist-container');
  // Create UI, track objects and append to playlist
  musicData.forEach((trackData, i) => {
    const trackObj = createTrackElement(trackData, i);
    tracks.push(trackObj);
    playlistRoot.appendChild(trackObj.container);
  });

  // Set initial button icons
  footerPlayBtn.innerHTML = playSVG;
  updateMuteButton();
  footerPrevBtn.innerHTML = prevSVG;
  footerNextBtn.innerHTML = nextSVG;

  // Initialize volume controls
  updateVolumeBar(1);
  updateVolumePercent(1);

  // Event handler for previous track button
  footerPrevBtn.addEventListener('click', () => {
    if (playingIndex === -1) return;
    playNextTrack(playingIndex - 2); // -2 because playNextTrack expects the index of the track that just ended
  });

  // Event handler for next track button
  footerNextBtn.addEventListener('click', () => {
    if (playingIndex === -1) return;

    // Check if we're at the last track
    if (playingIndex + 1 < tracks.length) {
      playNextTrack(playingIndex);
    }
    // If we're at the last track, don't change the play/pause button state
  });

  // Event handler for mute button
  footerMuteBtn.addEventListener('click', () => {
    isMuted = !isMuted;
    updateMuteButton();

    const currentVolume = parseFloat(footerVolumeInput.value);

    if (isMuted) {
      // Save the current volume from the slider
      prevVolume = (currentVolume === 0 ? 0.05 : currentVolume);

      // Mute all tracks regardless of playback state
      tracks.forEach(({ audio }) => {
        if (audio) audio.volume = 0;
      });
    } else {
      // Unmute all tracks using the volume from the slider
      tracks.forEach(({ audio }) => {
        if (audio) audio.volume = prevVolume;
      });
    }

    updateVolumeBar(isMuted ? 0 : prevVolume);
    updateVolumePercent(isMuted ? 0 : prevVolume);
    // Also update the volume slider value to reflect mute state
    footerVolumeInput.value = isMuted ? 0 : prevVolume;
  });

  // Update volume percentage when slider changes
  footerVolumeInput.addEventListener('input', e => {
    const vol = parseFloat(e.target.value);
    // Update prevVolume when user manually changes volume
    if (playingIndex >= 0) {
      prevVolume = vol;
    }
    updateVolumePercent(vol);
  });
  // Pause all audio on page unload for clean exit
  window.addEventListener('pagehide', () => {
    tracks.forEach(({ audio }) => {
      audio?.pause();
    });
  });
</script>
</body>
</html>
